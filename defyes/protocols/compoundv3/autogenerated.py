"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import Comet, CometRewards

# Optionally
class Comet(Comet):
    ...
"""
from karpatkit.cache import const_call
from karpatkit.node import get_node
from web3 import Web3

from defyes.generator import load_abi


class Comet:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "comet.json"))

    def balance_of(self, account: str) -> int:
        return self.contract.functions.balanceOf(account).call(block_identifier=self.block)

    @property
    def base_borrow_min(self) -> int:
        return self.contract.functions.baseBorrowMin().call(block_identifier=self.block)

    @property
    def base_min_for_rewards(self) -> int:
        return self.contract.functions.baseMinForRewards().call(block_identifier=self.block)

    @property
    def base_scale(self) -> int:
        return self.contract.functions.baseScale().call(block_identifier=self.block)

    @property
    def base_token(self) -> str:
        return const_call(self.contract.functions.baseToken())

    @property
    def base_token_price_feed(self) -> str:
        return self.contract.functions.baseTokenPriceFeed().call(block_identifier=self.block)

    @property
    def base_tracking_borrow_speed(self) -> int:
        return self.contract.functions.baseTrackingBorrowSpeed().call(block_identifier=self.block)

    @property
    def base_tracking_supply_speed(self) -> int:
        return self.contract.functions.baseTrackingSupplySpeed().call(block_identifier=self.block)

    def borrow_balance_of(self, account: str) -> int:
        return self.contract.functions.borrowBalanceOf(account).call(block_identifier=self.block)

    @property
    def borrow_kink(self) -> int:
        return self.contract.functions.borrowKink().call(block_identifier=self.block)

    @property
    def borrow_per_second_interest_rate_base(self) -> int:
        return self.contract.functions.borrowPerSecondInterestRateBase().call(block_identifier=self.block)

    @property
    def borrow_per_second_interest_rate_slope_high(self) -> int:
        return self.contract.functions.borrowPerSecondInterestRateSlopeHigh().call(block_identifier=self.block)

    @property
    def borrow_per_second_interest_rate_slope_low(self) -> int:
        return self.contract.functions.borrowPerSecondInterestRateSlopeLow().call(block_identifier=self.block)

    @property
    def decimals(self) -> int:
        return const_call(self.contract.functions.decimals())

    @property
    def extension_delegate(self) -> str:
        return self.contract.functions.extensionDelegate().call(block_identifier=self.block)

    def get_asset_info(self, i: int) -> tuple:
        return self.contract.functions.getAssetInfo(i).call(block_identifier=self.block)

    def get_asset_info_by_address(self, asset: str) -> tuple:
        return self.contract.functions.getAssetInfoByAddress(asset).call(block_identifier=self.block)

    def get_borrow_rate(self, utilization: int) -> int:
        return self.contract.functions.getBorrowRate(utilization).call(block_identifier=self.block)

    def get_collateral_reserves(self, asset: str) -> int:
        return self.contract.functions.getCollateralReserves(asset).call(block_identifier=self.block)

    def get_price(self, price_feed: str) -> int:
        return self.contract.functions.getPrice(price_feed).call(block_identifier=self.block)

    @property
    def get_reserves(self) -> int:
        return self.contract.functions.getReserves().call(block_identifier=self.block)

    def get_supply_rate(self, utilization: int) -> int:
        return self.contract.functions.getSupplyRate(utilization).call(block_identifier=self.block)

    @property
    def get_utilization(self) -> int:
        return self.contract.functions.getUtilization().call(block_identifier=self.block)

    @property
    def governor(self) -> str:
        return self.contract.functions.governor().call(block_identifier=self.block)

    def has_permission(self, owner: str, manager: str) -> bool:
        return self.contract.functions.hasPermission(owner, manager).call(block_identifier=self.block)

    @property
    def is_absorb_paused(self) -> bool:
        return self.contract.functions.isAbsorbPaused().call(block_identifier=self.block)

    def is_allowed(self, arg0: str, arg1: str) -> bool:
        return self.contract.functions.isAllowed(arg0, arg1).call(block_identifier=self.block)

    def is_borrow_collateralized(self, account: str) -> bool:
        return self.contract.functions.isBorrowCollateralized(account).call(block_identifier=self.block)

    @property
    def is_buy_paused(self) -> bool:
        return self.contract.functions.isBuyPaused().call(block_identifier=self.block)

    def is_liquidatable(self, account: str) -> bool:
        return self.contract.functions.isLiquidatable(account).call(block_identifier=self.block)

    @property
    def is_supply_paused(self) -> bool:
        return self.contract.functions.isSupplyPaused().call(block_identifier=self.block)

    @property
    def is_transfer_paused(self) -> bool:
        return self.contract.functions.isTransferPaused().call(block_identifier=self.block)

    @property
    def is_withdraw_paused(self) -> bool:
        return self.contract.functions.isWithdrawPaused().call(block_identifier=self.block)

    def liquidator_points(self, arg0: str) -> tuple[int, int, int, int]:
        """
        Output: numAbsorbs, numAbsorbed, approxSpend, _reserved
        """
        return self.contract.functions.liquidatorPoints(arg0).call(block_identifier=self.block)

    @property
    def num_assets(self) -> int:
        return self.contract.functions.numAssets().call(block_identifier=self.block)

    @property
    def pause_guardian(self) -> str:
        return self.contract.functions.pauseGuardian().call(block_identifier=self.block)

    def quote_collateral(self, asset: str, base_amount: int) -> int:
        return self.contract.functions.quoteCollateral(asset, base_amount).call(block_identifier=self.block)

    @property
    def store_front_price_factor(self) -> int:
        return self.contract.functions.storeFrontPriceFactor().call(block_identifier=self.block)

    @property
    def supply_kink(self) -> int:
        return self.contract.functions.supplyKink().call(block_identifier=self.block)

    @property
    def supply_per_second_interest_rate_base(self) -> int:
        return self.contract.functions.supplyPerSecondInterestRateBase().call(block_identifier=self.block)

    @property
    def supply_per_second_interest_rate_slope_high(self) -> int:
        return self.contract.functions.supplyPerSecondInterestRateSlopeHigh().call(block_identifier=self.block)

    @property
    def supply_per_second_interest_rate_slope_low(self) -> int:
        return self.contract.functions.supplyPerSecondInterestRateSlopeLow().call(block_identifier=self.block)

    @property
    def target_reserves(self) -> int:
        return self.contract.functions.targetReserves().call(block_identifier=self.block)

    @property
    def total_borrow(self) -> int:
        return self.contract.functions.totalBorrow().call(block_identifier=self.block)

    @property
    def total_supply(self) -> int:
        return self.contract.functions.totalSupply().call(block_identifier=self.block)

    def totals_collateral(self, arg0: str) -> tuple[int, int]:
        """
        Output: totalSupplyAsset, _reserved
        """
        return self.contract.functions.totalsCollateral(arg0).call(block_identifier=self.block)

    @property
    def tracking_index_scale(self) -> int:
        return self.contract.functions.trackingIndexScale().call(block_identifier=self.block)

    def user_basic(self, arg0: str) -> tuple[int, int, int, int, int]:
        """
        Output: principal, baseTrackingIndex, baseTrackingAccrued, assetsIn,
        _reserved
        """
        return self.contract.functions.userBasic(arg0).call(block_identifier=self.block)

    def user_collateral(self, arg0: str, arg1: str) -> tuple[int, int]:
        """
        Output: balance, _reserved
        """
        return self.contract.functions.userCollateral(arg0, arg1).call(block_identifier=self.block)

    def user_nonce(self, arg0: str) -> int:
        return self.contract.functions.userNonce(arg0).call(block_identifier=self.block)


class CometRewards:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "comet_rewards.json"))

    def get_reward_owed(self, comet: str, account: str) -> tuple:
        return self.contract.functions.getRewardOwed(comet, account).call(block_identifier=self.block)

    @property
    def governor(self) -> str:
        return self.contract.functions.governor().call(block_identifier=self.block)

    def reward_config(self, arg0: str) -> tuple[str, int, bool]:
        """
        Output: token, rescaleFactor, shouldUpscale
        """
        return self.contract.functions.rewardConfig(arg0).call(block_identifier=self.block)

    def rewards_claimed(self, arg0: str, arg1: str) -> int:
        return self.contract.functions.rewardsClaimed(arg0, arg1).call(block_identifier=self.block)
